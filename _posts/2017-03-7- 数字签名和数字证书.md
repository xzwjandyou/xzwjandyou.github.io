---
layout: post
title: '数字签名和数字证书'
tags: [language]
---
> 

---

## 非对称加密算法

生成者生成一对公私钥，即公钥和私钥，将私钥保留给自己，公钥公开给别人。

公钥和私钥之间无法反推，公钥加密私钥解密，私钥加密公钥解密，例如RSA算法。


相对其他对称加密，非对称加密相对比较耗时，所以一般用作签名用。


## 签名

摘要＋非对称加密 ＝> 签名

我这里简单说下应用场景：

假设有AB两个同学。

A同学生成一对公私钥，将私钥留给自己，公钥公开。

现在B同学要给A同学发消息，因为A的公钥时公开的，所以B就用A的公钥对内容加密。

B把消息加密后发送给A。

A收到B的消息后用私钥解密，拿到消息的内容，准备给B回复消息。

A用私钥加密要回复的消息形成，并将回复的消息hash取出摘要，并用私钥对摘要进行加密形成签名，然后将加密的消息和签名一并发给B。

B收到消息后，用公钥解密消息内容和签名，这样就拿到了消息原文和摘要。

接下来B要验证这条消息是否来自A，对原文hash出摘要，然后用这个摘要和刚刚解密的摘要进行比对看是否一致，如果一致那么就证明消息没有被篡改。

以上是签名的使用场景。

## 证书

还是刚才的例子，有个问题在于B如何知道她手上的公钥就是A的公钥呢？

证书的存在意义来了。

A先去证书中心去做认证，证书中心用用自己的私钥对A的公钥和基本信息加密，生成数字证书。

于是A就有了数字证书，并且是经过中心认证的（例如CA），给B发回复的是就把这个数字证书和其他一并发给B。

B收到消息后，用中心的公钥解开数字证书，就可以看到A的公钥了，保证此次拿到的是A的公钥。

问题解决。

## iOS中签名的应用

用户首先我们通过本地keychain导出一个叫做CertificateSigningRequest.cerSigningRequest 文件，然后提交给Applecenter，这个文件包含用户的一些基本信息，最重要的是里面包含用户的公钥，用户的私钥保存在keychain中。

苹果中心拿到了CertificateSigningRequest.cerSigningRequest文件，取出公钥然后加上一些账号信息做成数字证书。（即.cer文件）

用户下载到此证书。

双击证书之后，keychain自动将用户的私钥和公钥关联。

在打包的过程中，使用摘要算法对代码图片素材等进行摘要，然后用私钥对摘要进行签名，签名完成后和公钥一起打包成ipa包。（公钥是附带在mobileprovision文件中一起打包进app的）。

安装过程中，使用mobileprovisionl里面的公钥对程序和素材验证签名，保证程序完整合法，通过后就安装成功了。

解压后，得到上图的Payload目录，下面是个子目录，其中的内容如下：

1.资源文件，例如图片、html、等等。

2._CodeSignature/CodeResources。这是一个plist文件，可用文本查看，其中的内容就是是程序包中（不包括Frameworks）所有文件的签名。注意这里是所有文件。意味着你的程序一旦签名，就不能更改其中任何的东西，包括资源文件和可执行文件本身。iOS系统会检查这些签名。

3.可执行文件。此文件跟资源文件一样需要签名。

4.一个mobileprovision文件.打包的时候使用的，从MC上生成的。

5.Frameworks。程序引用的非系统自带的Frameworks，每个Frameworks其实就是一个app，其中的结构应该和app差不多，也包含签名信息CodeResources文件


这里提及一点，因为最近搞了重签名，如果app里面包含多个target，要从内往外依次签名，最后对当前的target签名，这样生成的摘要才没有被篡改过。

done。





