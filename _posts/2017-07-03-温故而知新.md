---
layout: post
title: '温故而知新'
tags: [language]
---
> 出自程序员的自我修养，之前读过前三章，后来因为觉得有的地方读起来觉得有点枯燥和不懂就没有继续读了，在看过TCP/IP，深入理解计算机系统，UNIX高级编程之后决定再将这本书重读一遍，而这一系列的文章就当是记忆的留存吧。

## 温故而知新
---
**计算机最重要的三个部件**：中央处理器CPU，内存，I/O控制芯片。<br>

**名人名言**：计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。<br>

从整个层次结构上来看，开发工具与应用程序是属于同一个层次的，因为她们都适用一个接口，那就是操作系统英语程序编程接口。应用程序接口的提供者是运行库，生养的运行库提供什么样的API。比如Linux下的Glibc库提供POSIX的API；Windows的运行库提供Windows API。<br>

**操作系统的功能**：提供抽象接口，管理硬件资源。<br>

**线程**：一个标准的线程由线程ID，当前指令指针（PC），寄存器集合和堆栈组成。通常意义上，一个进程由多个线程组成，各个线程之间共享程序的内存空间（包括代码段，数据段，堆等）及一些进程级的资源（如打开文件和信号）。

## 编译和链接
---
预处理 -> 编译 -> 汇编 -> 链接

**预处理**：预编译过程主要处理那些源代码文件中以“#”开始的预编译指令。
说明一点：处理“#include”预编译指令，将被包含的文件插入到该预编译指令的位置。注意这个过程是递归进行的，也就是说被包含的文件可能还包含其他文件。

**编译**：就是把预处理完的文件进行一系列词法分析，语法分析，语义分析及优化后产生相应的汇编代码文件，这个过程往往食我们所说的整个程序构建的核心部分，也是最复杂的部分。

**汇编**：将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都都应一条机器指令。

**链接**：人们把每个源代码模块独立地编译，然后按照需要将它们“组装”起来，这个组装模块的过程就是链接。链接过程主要包括了地址和空间分配，符号决议和重定位等这些步骤。地址修正的过程叫做重定位。

## 目标文件
---
**File Header**:描述了整个文件的额文件属性，包括文件是否可执行，是静态链接还是动态链接及入口地址，目标硬件，目标操作系统等信息，文件头还包括一个段表，段表其实是一个描述文件中各个段的数组。段表描述了文件中各个段仔文件中的便宜位置及段的属性等，从段表里面可以得到每个段的所有信息。<br>

**.text**：编译后可执行语句都编译成机器代码，保存在text段。<br>

**.data**：已初始化的全局变量和局部变量都保存在data段。<br>

**.bss**：未初始化的全局变量和局部静态变量一般放在一个叫bss段里。因为都是0所以在data段分配空间并且存放数据0是没有必要的。bss段知识为未初始化的全局变量和局部静态变量预留位置而已。它并没有内容，所以在文件中不占据空间。<br>

**为什么程序段和数据段分开**：程序只读，数据可读可写；提高缓存命中率；当系统运行着多个该程序的副本时，它们的指令都是一样的，所以内存中只需要保存一份该程序的指令部分。

**名人名言**：真正了不起的程序员对自己的程序的每一个字节都了如指掌。

在链接中，目标文件之间相互拼合实际上是文件之间对地址的引用，即对函数和变量的地址的饮用。

为了防止符号名冲突，UNIX下的C语言就规定，C语言源代码文件中的所有全局的变量和函数经过编译后，相对应的符号名前加上下划线“_”。例如foo编译后的符号名就是_foo。后期C++增加了名称空间的方法来解决冲突，现在的Linux下的GCC编译器中，默认情况下已经去掉了在C语言符号钱加“_”。

## 静态链接
---
**链接过程分为两步：**<br>
**第一步** 空间与地址分配。<br>
**第二步** 符号解析与重定位。

在链接之前，目标文件中的所有段的VMA都是0，因为虚拟空间还没有被分配，所以他们默认都为0。等到链接之后，可执行文件中的各个段都被分配了相应的虚拟地址。

其实一个静态库可以简单地堪称一组目标文件的集合，即很多目标文件经过压缩打包后形成的一个文件。链接器在链接静态库的时候是以目标文件为单位的。比如我们引用了静态库中的print函数，那么链接器就会把库中包含print函数的那个目标文件链接进来，如果很多函数都放在一个目标文件中，很可能很多没用的函数都被遗弃链接进了输出结果中。每个函数独立地放在一个目标文件中可以尽量减少空间的浪费。<br>
**链接控制**<br>
**链接控制脚本**<br>
**最小的helloword**<br>

## Windows PE/COFF
---
**映像（Image）**：因为PE文件在装载时被肢解映射到进程的虚拟空间中运行，它是进程的虚拟空间的映像。所以PE可执行文件很多时候被叫做映像文件。（在做app逆向的时候，生成的动态库就是注入到映像中）。

在windows系统装在PE可执行文件时，往往需要很快找到一些装载所需要的数据结构，比如导入表，导出表，资源，重定位等。这些数据的位置和长度都被爆存在了一个叫数据目录（data Directory）的结构里面。


## 可执行文件的装载与进程
---
**比喻**：说把程序和进程的概念跟做菜比较，程序就是菜谱，计算机的CPU就是人，相关的厨具则是计算机的其他硬件，整个炒菜的过程就是一个进程。

每个程序被运行起来以后，它将拥有自己的独立的虚拟地址空间（virtual address space）。这个虚拟地址空间的大小由计算机的硬件平台决定，具体地说是由CPU的位数决定的。硬件决定了地址空间的最大理论上线，即硬件的寻址空间大小。

程序运行时是有局部性原理的，所以我们可以将程序最常用的部分驻留在内存中，而将一些不太常用的数据存放在磁盘里，这就是动态装入的基本原理，覆盖装入（被淘汰）和页映射是两种典型的动态装载方法。

映射页也不是一下子就把程序的所有数据和指令都装入内存，而是将内存和所有磁盘中的数据和指令按照“页”为单位划分成若干个页，以后所有的装载和操作的单位就是。以目前的情况，硬件规定的页的大小有4096字节，8192字节，2MB等。

**操作系统视角**：<br>
1.创建一个独立的虚拟地址空间。<br>
2.读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系。<br>
3.将CPU的指令寄存器设置成可执行文件的入口地址，启动运行<br>

**进程虚拟地址空间**：操作系统通过给进程空间划分出一个个VMA来管理进程的虚拟空间；基本原则是将相同权限属性的，有相同映像文件的映射成一个VMA；一个进程基本上可以分为以下几种VMA区域：<br>
**1.代码VMA，只读，可执行，有映像文件。**<br>
**2.数据VMA，可读写，可执行，有映像文件。**<br>
**3.堆VMA，可读写，可执行，无映像文件，匿名，可向上扩展。**<br>
**4.栈VMA，可读写，不可执行，无映像文件，匿名，可向下扩展。**<br>

**Linux内核装载ELF过程**：
在用户层面，bash进程会调用fork（）系统调用创建一个新的进程，然后新的进程调用execve（）系统调用执行指定的ELF文件，原先的bash进程继续返回等待刚才启动的新进程结束，然后继续等待用户输入命令。在进入execve系统调用之后，linux内核就开始真正的装载工作。P174.

## 动态链接
---

